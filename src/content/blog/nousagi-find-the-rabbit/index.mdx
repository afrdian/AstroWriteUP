---
title: 'Nousagi CTF Write Up: Find the Rabbit (MT19937 1-bit Ambiguity Exploit)'
description: 'Step-by-step write-up for Nousagi: analyzing chall.py, exploiting MT19937 state timing, and solving the remote service at 103.16.116.156:8000 with process_server_solver.py.'
date: 2026-02-19
tags: ['ctf', 'cryptography', 'python', 'mt19937', 'writeup']
authors: ['enscribe']
---

## Challenge Info

- Challenge: `Find the rabbit`
- Type: Crypto / PRNG state attack
- Remote service: `nc 103.16.116.156 8000`
- Goal: Make server print `"You found the rabbit!"` and return the flag.

---

## Source Code (`chall.py`)

```python
import randcrack
import random
import os
from libnum import s2n
import signal

seed = os.urandom(12)
wack = randcrack.RandCrack()
random.seed(seed)

print("Find the rabbit!")
for _ in range(624):
    signal.alarm(2) # Dont waste time
    num = int(input(">> "))
    signal.alarm(0)

    wack.submit(num)
    print(random.getrandbits(32))

rabbit = 0
for _ in range(624):
    rabbit ^= random.getrandbits(32) ^ wack.predict_getrandbits(32)
    
if abs(rabbit) < s2n(b'ribbit') % 1337:
    print("You found the rabbit!")
    gift = open('flag.txt').read()
    print(gift)
else:
    print("You didn't find the rabbit, try again!")
    print("Rabbit was:", rabbit)
    exit(1)
```

---

## Step 1: Understand the Win Condition

The challenge does two phases:

1. For 624 rounds:
   - We send one integer (`num`)
   - Server calls `wack.submit(num)`
   - Then server prints one real RNG output from Python MT19937
2. Next 624 rounds:
   - `rabbit ^= real_output ^ wack_prediction`

Win condition:

```python
abs(rabbit) < s2n(b'ribbit') % 1337
```

`s2n(b"ribbit") % 1337 = 1`, so we need:

`rabbit == 0`

That means:

`XOR(real_next_624_outputs) == XOR(wack_next_624_predictions)`

---

## Step 2: Why Normal RandCrack Is Not Enough

A common mistake is trying to fully clone MT state directly from printed outputs.

The ordering is:

- input first
- output second

So at round 623, we must submit final value **before** seeing the 624th printed number.  
This creates a timing gap and prevents straightforward full-state control.

---

## Step 3: Key MT19937 Insight (In-place Twist)

Python MT19937 updates state in-place.  
From observed outputs `r0..r622` we can untemper and recover `mt1[0..622]`.

Only one part remains ambiguous for the final first-phase word: `mt1[623]`.

Using twist structure:

`mt1[623] = mt1[396] XOR g(mt0[623], mt1[0])`

In this expression, the uncertainty collapses to **one bit** (`msb(mt0[623])`), so there are only **2 valid candidates** for the hidden branch.

This is the breakthrough:

- We do not need full unknown 32-bit output at that point.
- We only need to guess 1 bit (50% chance each connection).

---

## Step 4: Build the Target XOR We Need

Let:

- `S = XOR(real outputs in phase 2)`
- `P = XOR(wack predictions in phase 2)`

Need `S == P`.

For each guessed hidden bit (0 or 1), we build candidate `mt1[623]`, twist once to `mt2`, temper all 624 words, and compute candidate `S`.

So we get one `S_guess` per connection (based on chosen hidden bit guess).

---

## Step 5: Force `P` with Linear Algebra

`wack` state is controlled by our 624 submitted numbers.

We submit:

- round 0: `0`
- rounds 1..622: previous received output

This fixes first 623 internal words in a known way.

Only final submitted word remains free.  
The mapping from this 32-bit final word to final XOR prediction `P` is linear over GF(2):

`P = P_base XOR A * x`

- `x`: 32-bit variable (final internal word)
- `A`: 32x32 binary matrix (built by basis probing)

We solve:

`A * x = S_guess XOR P_base`

Then submit `temper(x)` as final round input.

If hidden 1-bit guess is right, we get `rabbit == 0` and win.  
If wrong, retry on next connection. Success per attempt is ~50%.

---

## Step 6: Attack Workflow

1. Connect to `103.16.116.156:8000`
2. Read 623 outputs while sending lagged values.
3. Compute candidate phase-2 target XOR from one-bit guess.
4. Solve 32x32 GF(2) for final controllable word.
5. Send final value.
6. If fail, reconnect and repeat.

Probability after `k` attempts:

`1 - (1/2)^k`

Examples:

- 5 attempts: 96.875%
- 10 attempts: 99.902%

---

## Solver Usage

Use this process-logging solver:

- file: `process_server_solver.py`
- remote: `103.16.116.156`
- port: `8000`

Run:

```bash
python process_server_solver.py --host 103.16.116.156 --port 8000 --max-attempts 20 --timeout 5
```

This solver prints every sent and received number (`[round xxx] send=...`, `[round xxx] recv=...`) so you can see the full process.

---

## Full Solver Code (`process_server_solver.py`)

```python
#!/usr/bin/env python3
import argparse
import random
import re
import socket

from randcrack import RandCrack

N = 624
M = 397
MATRIX_A = 0x9908B0DF
LOWER_MASK = 0x7FFFFFFF
UPPER_MASK = 0x80000000

HELPER = RandCrack()


def bits32(x: int) -> list[int]:
    return [(x >> i) & 1 for i in range(31, -1, -1)]


def bits_to_int(bits: list[int]) -> int:
    v = 0
    for b in bits:
        v = (v << 1) | b
    return v


def temper_word(word: int) -> int:
    return bits_to_int(HELPER._harden(bits32(word)))


def untemper_output(output: int) -> int:
    return bits_to_int(HELPER._harden_inverse(bits32(output)))


def temper(y: int) -> int:
    y ^= y >> 11
    y ^= (y << 7) & 0x9D2C5680
    y ^= (y << 15) & 0xEFC60000
    y ^= y >> 18
    return y & 0xFFFFFFFF


def twist_inplace(mt: list[int]) -> list[int]:
    mt = mt[:]
    for kk in range(0, N - M):
        y = (mt[kk] & UPPER_MASK) | (mt[kk + 1] & LOWER_MASK)
        mt[kk] = (mt[kk + M] ^ (y >> 1) ^ (MATRIX_A if (y & 1) else 0)) & 0xFFFFFFFF
    for kk in range(N - M, N - 1):
        y = (mt[kk] & UPPER_MASK) | (mt[kk + 1] & LOWER_MASK)
        mt[kk] = (mt[kk + (M - N)] ^ (y >> 1) ^ (MATRIX_A if (y & 1) else 0)) & 0xFFFFFFFF
    y = (mt[N - 1] & UPPER_MASK) | (mt[0] & LOWER_MASK)
    mt[N - 1] = (mt[M - 1] ^ (y >> 1) ^ (MATRIX_A if (y & 1) else 0)) & 0xFFFFFFFF
    return mt


def future_xor_from_mt1(mt1: list[int]) -> int:
    mt2 = twist_inplace(mt1)
    x = 0
    for w in mt2:
        x ^= temper(w)
    return x


def predicted_xor_from_words(words: list[int]) -> int:
    w = RandCrack()
    for word in words:
        w.submit(temper_word(word))
    x = 0
    for _ in range(624):
        x ^= w.predict_getrandbits(32)
    return x


def build_last_word_columns() -> list[int]:
    base = [0] * 624
    p0 = predicted_xor_from_words(base)
    cols = []
    for bit in range(32):
        probe = [0] * 624
        probe[623] = 1 << bit
        cols.append(predicted_xor_from_words(probe) ^ p0)
    return cols


def solve_last_word(cols: list[int], target: int) -> int:
    rows = []
    for bit in range(32):
        coeff = 0
        for i, col in enumerate(cols):
            if (col >> bit) & 1:
                coeff |= 1 << i
        rows.append([coeff, (target >> bit) & 1])

    where = [-1] * 32
    r = 0
    for col in range(32):
        pivot = None
        for i in range(r, 32):
            if (rows[i][0] >> col) & 1:
                pivot = i
                break
        if pivot is None:
            continue
        rows[r], rows[pivot] = rows[pivot], rows[r]
        where[col] = r
        for i in range(32):
            if i != r and ((rows[i][0] >> col) & 1):
                rows[i][0] ^= rows[r][0]
                rows[i][1] ^= rows[r][1]
        r += 1

    x = 0
    for col in range(32):
        if where[col] != -1 and rows[where[col]][1]:
            x |= 1 << col

    check = 0
    for i in range(32):
        if (x >> i) & 1:
            check ^= cols[i]
    if check != target:
        raise ValueError("GF(2) solve failed")
    return x


def candidate_future_xor(outputs_0_622: list[int], bit_guess: int) -> int:
    v = [untemper_output(o) for o in outputs_0_622]
    v0 = v[0]
    v396 = v[396]

    y = ((bit_guess & 1) << 31) | (v0 & LOWER_MASK)
    g = ((y >> 1) ^ (MATRIX_A if (y & 1) else 0)) & 0xFFFFFFFF
    v623 = v396 ^ g

    mt1 = v + [v623]
    return future_xor_from_mt1(mt1)


def extract_int(line: str) -> int:
    m = re.search(r"-?\d+", line)
    if not m:
        raise ValueError(f"Could not parse int from line: {line!r}")
    return int(m.group(0))


class Remote:
    def __init__(self, host: str, port: int, timeout: float):
        self.sock = socket.create_connection((host, port), timeout=timeout)
        self.sock.settimeout(timeout)
        self.buf = b""

    def close(self) -> None:
        try:
            self.sock.close()
        except OSError:
            pass

    def recv_until(self, token: bytes) -> bytes:
        while token not in self.buf:
            chunk = self.sock.recv(4096)
            if not chunk:
                raise RuntimeError("Remote closed while waiting for token")
            self.buf += chunk
        idx = self.buf.index(token) + len(token)
        out = self.buf[:idx]
        self.buf = self.buf[idx:]
        return out

    def recv_line(self) -> str:
        while b"\n" not in self.buf:
            chunk = self.sock.recv(4096)
            if not chunk:
                raise RuntimeError("Remote closed while waiting for line")
            self.buf += chunk
        idx = self.buf.index(b"\n") + 1
        out = self.buf[:idx]
        self.buf = self.buf[idx:]
        return out.decode(errors="ignore").strip()

    def send_line(self, line: str) -> None:
        self.sock.sendall(line.encode() + b"\n")

    def recv_tail(self, idle_timeout: float = 0.8) -> str:
        old_timeout = self.sock.gettimeout()
        self.sock.settimeout(idle_timeout)
        out = self.buf
        self.buf = b""
        try:
            while True:
                chunk = self.sock.recv(4096)
                if not chunk:
                    break
                out += chunk
        except socket.timeout:
            pass
        finally:
            self.sock.settimeout(old_timeout)
        return out.decode(errors="ignore")


def single_attempt(host: str, port: int, cols: list[int], timeout: float) -> tuple[bool, str]:
    io = Remote(host, port, timeout)
    try:
        banner = io.recv_until(b">> ").decode(errors="ignore").strip()
        print(f"[server] {banner}")

        outputs: list[int] = []

        # Round 0
        send_val = 0
        print(f"[round 000] send={send_val}")
        io.send_line(str(send_val))
        recv_line = io.recv_line()
        recv_val = extract_int(recv_line)
        outputs.append(recv_val)
        print(f"[round 000] recv={recv_val}")
        io.recv_until(b">> ")

        # Rounds 1..622: submit previous output.
        for i in range(1, 623):
            send_val = outputs[i - 1]
            print(f"[round {i:03d}] send={send_val}")
            io.send_line(str(send_val))
            recv_line = io.recv_line()
            recv_val = extract_int(recv_line)
            outputs.append(recv_val)
            print(f"[round {i:03d}] recv={recv_val}")
            io.recv_until(b">> ")

        words = [untemper_output(0)] + [untemper_output(outputs[i - 1]) for i in range(1, 623)]

        bit_guess = random.getrandbits(1)
        target = candidate_future_xor(outputs, bit_guess)
        pbase = predicted_xor_from_words(words + [0])
        last_word = solve_last_word(cols, target ^ pbase)
        final_submit = temper_word(last_word)

        print(
            f"[final] bit_guess={bit_guess} target={target} "
            f"pbase={pbase} submit={final_submit}"
        )
        io.send_line(str(final_submit))
        final_out_line = io.recv_line()
        final_out = extract_int(final_out_line)
        print(f"[round 623] recv={final_out}")

        tail = io.recv_tail()
        if tail.strip():
            print("[tail]")
            print(tail.strip())
        return ("You found the rabbit!" in tail), tail
    finally:
        io.close()


def main() -> None:
    parser = argparse.ArgumentParser(description="Process-logging remote exploit solver")
    parser.add_argument("--host", default="103.16.116.156", help="remote host")
    parser.add_argument("--port", type=int, default=8000, help="remote port")
    parser.add_argument("--max-attempts", type=int, default=20, help="retry count (~50% per attempt)")
    parser.add_argument("--timeout", type=float, default=5.0, help="socket timeout seconds")
    args = parser.parse_args()

    cols = build_last_word_columns()
    print("[*] Prepared linear map for final-word control.")

    for attempt in range(1, args.max_attempts + 1):
        print(f"\n=== Attempt {attempt} ===")
        try:
            ok, tail = single_attempt(args.host, args.port, cols, args.timeout)
        except Exception as exc:
            print(f"[-] Attempt {attempt} error: {exc}")
            continue

        if ok:
            print(f"[+] Success on attempt {attempt}")
            if tail.strip():
                print(tail.strip())
            return
        print(f"[-] Attempt {attempt} failed")

    print("[!] No success within max attempts; rerun for more retries.")


if __name__ == "__main__":
    main()
```

---

## Notes

- This exploit is not brute-force over 32 bits. It reduces uncertainty to a single hidden MT branch bit, then solves a deterministic GF(2) system for the final controllable word.
- Expected success is ~50% each new connection; retries make success fast in practice.
